# 问诊系统完整技术文档

## 目录
1. [系统概述](#系统概述)
2. [完整问诊流程](#完整问诊流程)
3. [核心算法：概率计算（加分制）](#核心算法概率计算加分制)
4. [智能问题选择算法](#智能问题选择算法)
5. [诊断结束条件](#诊断结束条件)
6. [数据结构详解](#数据结构详解)
7. [API接口规范](#api接口规范)
8. [关键公式总结](#关键公式总结)
9. [算法优化与改进](#算法优化与改进)

---

## 系统概述

### 核心组件
- **DiagnosisService**: 核心诊断服务类，负责概率计算、问题选择、结束判断
- **DiagnosisServlet**: HTTP接口层，处理前端请求
- **DiagnosisSession**: 诊断会话状态管理
- **数据库表**: `diseases`, `symptoms`, `disease_symptoms`

### 算法特点
- **加分制算法**：使用匹配度百分比，而非传统概率计算
- **智能问题选择**：聚焦Top疾病，优先选择最有价值的问题
- **动态结束阈值**：根据问题数量动态调整结束条件
- **主诉权重增强**：不包含主诉的疾病概率降低50%
- **分级惩罚机制**：必需症状被否定时，根据权重分级惩罚
- **不确定选项**：支持用户回答"不确定"，不触发必需症状惩罚

---

## 完整问诊流程

### 阶段1：页面初始化

#### 1.1 页面加载
**文件**: `consultation.html`

**初始化变量**：
```javascript
let currentSymptomId = null;              // 当前问题的症状ID
let selectedSymptoms = [];                // 用户选择"是"的症状ID列表
let askedSymptoms = [];                   // 所有已问过的症状ID列表（包括"是"、"否"、"不确定"）
let uncertainSymptoms = [];               // 用户回答"不确定"的症状ID列表
let questionCount = 0;                    // 已回答的问题总数
let questionHistory = [];                 // 问题历史记录（用于返回功能）
let mainComplaintId = null;               // 主诉症状ID
let currentQuestion = null;               // 当前结构化问题
let diagnosisFinished = false;             // 诊断是否完成标志
```

#### 1.2 加载主诉选项
**前端操作**：
- 调用 `loadMainComplaints()`
- 发送请求：`GET /petblog/api/diagnosis/main-complaints`

**后端处理** (`DiagnosisServlet.doGet()`):
1. 调用 `StructuredQuestionService.getMainComplaintQuestions()`
2. 从数据库查询所有症状，按 `category` 分组
3. 生成主诉选项，每个选项代表一个症状类别
4. 特殊处理："全身"类别显示为"发热"

**返回数据格式**：
```json
{
  "questions": [
    {
      "symptomId": 1,
      "symptomName": "发热",
      "questionText": "您的宠物是否有发热相关的症状？"
    }
  ]
}
```

---

### 阶段2：主诉选择

#### 2.1 用户选择主诉
**触发**: 用户点击某个主诉选项

**前端处理** (`selectMainComplaint(symptomId, symptomName)`)：
```javascript
mainComplaintId = symptomId;
selectedSymptoms.push(symptomId);  // 主诉自动加入已选择症状
askedSymptoms.push(symptomId);     // 主诉自动加入已问列表
questionCount++;                    // 问题计数+1

// 界面切换
隐藏主诉选择区域
显示问诊区域
显示问题卡片

// 直接进入决策树问诊
await getNextQuestion();
```

---

### 阶段3：决策树问诊循环（核心）

这是一个循环过程，每次循环包含以下步骤：

#### 3.1 获取下一个问题

##### 3.1.1 前端请求
**API**: `POST /petblog/api/diagnosis/next`

**请求体**：
```json
{
  "selectedSymptoms": [1, 2, 3],           // 用户选择"是"的症状ID列表
  "askedSymptoms": [1, 2, 3, 4, 5],        // 所有已问过的症状ID
  "uncertainSymptoms": [6],                // 回答"不确定"的症状ID列表
  "questionCount": 5,                      // 已回答的问题总数
  "mainComplaintId": 1,                    // 主诉症状ID
  "questionHistory": [...]                 // 问题历史
}
```

##### 3.1.2 后端处理流程

**步骤1：解析请求并创建会话**
```java
DiagnosisSession session = new DiagnosisSession();
session.setSelectedSymptoms(selectedSymptoms);
session.setAskedSymptoms(askedSymptoms);
session.setUncertainSymptoms(uncertainSymptoms);
session.setQuestionCount(questionCount);
session.setMainComplaintId(mainComplaintId);
```

**步骤2：调用诊断服务**
```java
Map<String, Object> result = diagnosisService.nextStep(session);
```

**`DiagnosisService.nextStep()` 执行流程**：

```
┌─────────────────────────────────────┐
│  1. 计算所有疾病的概率               │
│     calculateProbabilities()        │
│     - 使用加分制算法                 │
│     - 应用主诉权重增强               │
│     - 应用分级惩罚机制               │
└────────────┬────────────────────────┘
             │
             ↓
┌─────────────────────────────────────┐
│  2. 检查是否应该结束诊断             │
│     shouldStopDiagnosis()           │
│     - 最少问题数检查（8个）         │
│     - 绝对阈值检查                   │
│     - 相对优势检查                   │
│     - 强制结束检查（30个问题）       │
└────────────┬────────────────────────┘
             │
        ┌────┴────┐
        │         │
      true      false
        │         │
        ↓         ↓
  返回结果    继续问诊
        │         │
        │         ↓
        │  3. 选择下一个最佳问题
        │     selectNextQuestion()
        │     - 聚焦Top3疾病
        │     - 计算候选症状得分
        │     - 选择得分最高的
        │
        └─────┬───┘
              │
       返回结果或问题
```

#### 3.2 用户回答问题

**用户点击"是"、"否"或"不确定"按钮**

**前端处理** (`answerQuestion(answer)`)：
```javascript
// answer: true=是, false=否, null=不确定

questionCount++;  // 问题计数+1

// 保存到历史记录
questionHistory.push({
    symptomId: currentSymptomId,
    name: questionTitle,
    description: questionDesc,
    answer: answer
});

// 更新已问列表
if (!askedSymptoms.includes(currentSymptomId)) {
    askedSymptoms.push(currentSymptomId);
}

// 根据答案类型更新不同列表
if (answer === true) {
    // 选择"是"：添加到已选择列表
    if (!selectedSymptoms.includes(currentSymptomId)) {
        selectedSymptoms.push(currentSymptomId);
    }
    // 从不确定列表中移除（如果存在）
    removeFromUncertain(currentSymptomId);
    
} else if (answer === null) {
    // 选择"不确定"：添加到不确定列表
    if (!uncertainSymptoms.includes(currentSymptomId)) {
        uncertainSymptoms.push(currentSymptomId);
    }
    // 从已选择列表中移除（如果存在）
    removeFromSelected(currentSymptomId);
    
} else if (answer === false) {
    // 选择"否"：从已选择和不确定列表中移除
    removeFromSelected(currentSymptomId);
    removeFromUncertain(currentSymptomId);
}

// 获取下一个问题
await getNextQuestion();
```

---

### 阶段4：诊断结果展示

#### 4.1 显示诊断结果
当 `shouldStopDiagnosis()` 返回 `true` 时，前端调用 `showDiagnosisResult(data)`

**结果数据格式**：
```json
{
  "finished": true,
  "diseases": [
    {
      "diseaseId": 1,
      "disease": "感冒",
      "probability": 0.65,
      "description": "疾病描述...",
      "evidenceSymptoms": [
        {"symptomName": "咳嗽"},
        {"symptomName": "发热"}
      ],
      "recommendation": "建议..."
    }
  ]
}
```

#### 4.2 保存问诊记录
**API**: `POST /petblog/api/diagnosis/save`

---

## 核心算法：概率计算（加分制）

### 算法概述

**核心思想**：使用匹配度百分比，而非传统的朴素贝叶斯概率计算

**核心公式**：
```
匹配度 = 当前命中症状的总权重 / 该疾病所有症状的总权重
概率 = 匹配度（经过惩罚和限制后）
```

### 详细计算步骤

#### 步骤1：遍历每个疾病

对于数据库中的每个疾病 $D$：

#### 步骤2：初始化变量

```java
double totalPossibleScore = 0.0;          // 分母：该疾病所有症状的总权重
double currentScore = 0.0;                // 分子：当前命中症状的总权重
boolean criticalSymptomMissing = false;    // 标记：是否强必需症状被否定
boolean weakRequiredSymptomMissing = false; // 标记：是否弱必需症状被否定
boolean hasExclusiveSymptom = false;       // 标记：是否有特异性症状被选中
boolean containsMainComplaint = false;     // 标记：疾病是否包含主诉症状
```

#### 步骤3：检查主诉

```java
if (mainComplaintId != null) {
    containsMainComplaint = symptoms.stream()
        .anyMatch(ds -> ds.getSymptomId().equals(mainComplaintId));
}
```

#### 步骤4：遍历疾病的所有症状

对于疾病 $D$ 的每个症状 $s$：

**4.1 获取基础权重**
```java
double weight = (ds.getWeight() != null) ? ds.getWeight() : 100.0;
```

**4.2 计算有效权重**
```java
// 如果是必需症状，权重加倍
double effectiveWeight = (ds.getIsRequired() != null && ds.getIsRequired()) 
                        ? weight * 2.0 
                        : weight;
```

**4.3 累加总分（分母）**
```java
totalPossibleScore += effectiveWeight;
```

**4.4 计算当前得分（分子）**

根据用户的选择情况：

**情况1：症状被选中（在 selectedIds 中）**
```java
if (selectedIds.contains(symptomId)) {
    // 命中症状，加分（使用有效权重）
    currentScore += effectiveWeight;
    
    // 新增：特异性症状奖励
    if (ds.getIsExclusive() != null && ds.getIsExclusive()) {
        // 特异性症状被选中，给予巨大加分（500分），确保该病直接冲到第一名
        currentScore += 500.0;
        hasExclusiveSymptom = true;
    }
}
```

**特异性症状说明**：
- **定义**：某些疾病独有的、具有高度诊断价值的症状（如"犬细小"的腥臭血便、"耳螨"的耳道黑褐色分泌物）
- **作用**：当特异性症状被选中时，对应疾病的概率会直接提升到95%（接近确诊）
- **实现**：在数据库中将特征性症状标记为 `is_exclusive=1`

**情况2：症状被明确回答"否"（在 askedIds 中但不在 selectedIds 中，且不在 uncertainIds 中）**
```java
else if (askedIds.contains(symptomId) && !uncertainIds.contains(symptomId)) {
    // 用户明确回答了"否"
    if (ds.getIsRequired() != null && ds.getIsRequired()) {
        // 判断是强必需还是弱必需
        double symptomWeight = (ds.getWeight() != null) ? ds.getWeight() : 100.0;
        if (symptomWeight > 80.0) {
            // 强必需症状被否定
            criticalSymptomMissing = true;
        } else {
            // 弱必需症状被否定
            weakRequiredSymptomMissing = true;
        }
    }
    // 注意：普通症状被否定时，不加减分
    // 因为它无法获得分数，这本身就是一种惩罚（分母大了，但分子没增加）
}
```

**情况3：症状被回答"不确定"（在 uncertainIds 中）**
```java
// 如果症状在uncertainIds中，既不加分也不触发必需症状惩罚
// 保留"未来的可能性"
```

**情况4：症状还没问过（不在 askedIds 中）**
```java
// 既不加分也不减分
// 它们保留了"未来的可能性"
```

#### 步骤5：计算基础概率

```java
double probability = 0.0;
if (totalPossibleScore > 0.0) {
    probability = currentScore / totalPossibleScore;
}
```

**示例计算**：
- 疾病有5个症状：权重分别为 [80, 60, 90, 70, 85]
- 其中第3个是必需症状（权重90×2=180）
- TotalScore = 80 + 60 + 180 + 70 + 85 = 475
- 用户选择了症状1（权重80）和症状3（必需，权重180）
- CurrentScore = 80 + 180 = 260
- probability = 260 / 475 = 0.547 = 54.7%

#### 步骤6：特异性症状奖励

**6.1 特异性症状直接提升概率**
```java
if (hasExclusiveSymptom) {
    // 如果有特异性症状被选中，直接提升概率到95%（接近确诊）
    probability = 0.95;
} else {
    // 只有在没有特异性症状时，才应用其他惩罚逻辑
    // ...
}
```

**特异性症状的逻辑**：
- 当疾病的某个症状被标记为 `is_exclusive=1` 且该症状被用户选中时
- 该疾病的概率直接设为95%（最高概率上限）
- 这样做的原因：特异性症状是某些疾病独有的、高度特征性的症状
- 例如："犬细小病毒"的腥臭血便、"耳螨感染"的耳道黑褐色分泌物等

#### 步骤7：应用惩罚（仅在无特异性症状时）

**7.1 必需症状否定惩罚**
```java
if (!hasExclusiveSymptom) {  // 只有在没有特异性症状时才应用惩罚
    if (criticalSymptomMissing) {
        // 强必需症状被否定，概率大幅降低
        probability *= 0.1;  // 降低到原来的10%
    } else if (weakRequiredSymptomMissing) {
        // 弱必需症状被否定，概率适度降低
        probability *= 0.4;  // 降低到原来的40%
    }
}
```

**7.2 主诉权重增强**
```java
if (!hasExclusiveSymptom && mainComplaintId != null && !containsMainComplaint) {
    // 如果疾病不包含主诉症状，概率降低50%（仅在无特异性症状时应用）
    probability *= 0.5;
}
```

**示例**：
- 基础概率：54.7%
- 如果必需症状被否定（强必需）：54.7% × 0.1 = 5.47%
- 如果疾病不包含主诉：54.7% × 0.5 = 27.35%

#### 步骤8：限制最大概率

```java
if (probability > 0.95) {
    probability = 0.95;  // 最高95%，从实际出发不应该有100%的概率
}
```

**注意**：特异性症状奖励已经在步骤6中将概率设为95%，这一步主要是作为安全检查。

#### 步骤9：过滤和排序

```java
// 过滤掉极低概率（<1%）
if (probability > 0.01) {
    results.add(result);
}

// 按概率降序排序
Collections.sort(results, (a, b) -> Double.compare(b.getProbability(), a.getProbability()));
```

---

## 智能问题选择算法

### 算法目标

从所有可能的问题中，选择**最有价值**的问题，即：能够最大程度区分不同疾病的问题。

### 选择策略

#### 策略1：聚焦Top疾病

只关注概率最高的前3名疾病，从这些疾病的关联症状中选择问题。

```java
List<Integer> topDiseaseIds = rankedDiseases.stream()
    .limit(3)
    .map(dr -> dr.getDisease().getId())
    .collect(Collectors.toList());
```

#### 策略2：候选症状获取

**步骤1：从Top3疾病获取候选症状**
```java
List<SymptomWithWeight> candidates = symptomDAO.findCandidateSymptoms(
    topDiseaseIds, 
    session.getAskedSymptoms()  // 排除已问过的症状
);
```

**步骤2：回退机制 - 扩展到Top5**
如果Top3疾病没有候选症状：
```java
if (candidates.isEmpty() && rankedDiseases.size() > 3) {
    // 扩展到Top5
    top5DiseaseIds = rankedDiseases.stream().limit(5)...
    candidates = symptomDAO.findCandidateSymptoms(top5DiseaseIds, ...);
}
```

**步骤3：回退机制 - 从主诉类别补充**
如果Top疾病都没有候选症状：
```java
if (candidates.isEmpty() && mainComplaintCategory != null) {
    // 从主诉类别中获取同类别症状
    List<Symptom> categorySymptoms = symptomDAO.findByCategory(
        mainComplaintCategory, 
        session.getAskedSymptoms(), 
        10  // 最多10个
    );
    // 转换为SymptomWithWeight，使用默认权重1.0
}
```

**步骤4：补充候选症状（如果候选太少）**
如果候选症状少于3个：
```java
if (candidates.size() < 3 && mainComplaintCategory != null) {
    // 从主诉类别补充，使用权重0.8（略低于正常）
    // ...
}
```

#### 策略3：计算候选症状得分

对每个候选症状，计算其"信息价值"得分：

```java
// 构建疾病ID到概率的映射
Map<Integer, Double> diseaseProbMap = ...;

// 计算每个症状的得分
for (候选症状 s) {
    double score = 0.0;
    
    // 遍历该症状关联的所有Top疾病
    for (疾病 d in 该症状关联的疾病) {
        double diseaseProb = diseaseProbMap.get(d.id);
        
        // 获取症状权重
        double weight = s.weight;
        if (s.isRequired) {
            weight *= 1.5;  // 必需症状加权
        }
        
        // 得分 = 症状权重 × 疾病概率
        score += weight * diseaseProb;
    }
    
    // 如果症状类别与主诉类别相同，得分增加50%
    if (s.category == mainComplaintCategory) {
        score *= 1.5;
    }
}
```

**得分计算公式**：
```
Score(symptom s) = Σ [weight(s,d) × P(d)] × categoryBonus(s)

其中：
  weight(s,d) = {
    baseWeight(s,d) × 1.5  if s is required in d
    baseWeight(s,d)         otherwise
  }
  
  categoryBonus(s) = {
    1.5  if category(s) == category(mainComplaint)
    1.0  otherwise
  }
```

#### 策略4：选择最佳症状

```java
// 按得分排序
scoredSymptoms.sort(降序);

// 总是选择得分最高的症状
// 但避免重复最近问过的3个症状
for (SymptomScore ss in scoredSymptoms) {
    if (!session.isRecentlyAsked(ss.symptom.id)) {
        bestSymptom = ss.symptom;
        break;
    }
}

// 如果所有候选都最近问过，选择得分最高的（避免无法继续）
if (bestSymptom == null) {
    bestSymptom = scoredSymptoms.get(0).symptom;
}

// 记录到最近问过列表（最多保存3个）
session.addRecentAskedSymptom(bestSymptom.id);
```

#### 策略5：截断机制

如果最佳问题得分极低且问题数很多，触发强制结束：

```java
if (maxScore < 0.01 && session.getQuestionCount() >= 15) {
    return null;  // 触发强制结束诊断
}
```

---

## 诊断结束条件

### 结束条件概述

系统会检查三个条件，满足任一条件即结束诊断：

1. **绝对阈值条件**
2. **相对优势条件**
3. **强制结束条件**

### 条件1：最少问题数要求

**硬性要求**：至少问8个问题（不包括主诉）才可能结束诊断。

```java
int minQuestions = 8;
if (questionCount < minQuestions) {
    return false;  // 继续问诊
}
```

### 条件2：绝对阈值条件

根据已问问题数，动态调整阈值：

```java
double threshold;
if (questionCount <= 8) {
    threshold = 0.90;   // 前8个问题需要90%以上概率
} else if (questionCount <= 12) {
    threshold = 0.85;   // 9-12个问题需要85%以上概率
} else if (questionCount <= 16) {
    threshold = 0.75;   // 13-16个问题需要75%以上概率
} else if (questionCount <= 20) {
    threshold = 0.65;   // 17-20个问题需要65%以上概率
} else {
    threshold = 0.55;   // 21个问题以上需要55%以上概率
}

if (topProb >= threshold) {
    return true;  // 结束诊断
}
```

**阈值表**：

| 问题数 | 结束阈值 |
|--------|----------|
| ≤ 8    | 90%      |
| 9-12   | 85%      |
| 13-16  | 75%      |
| 17-20  | 65%      |
| ≥ 21   | 55%      |

### 条件3：相对优势条件

如果第一名明显领先第二名，且问题数足够多，可以提前结束：

```java
if (probs.size() > 1 && questionCount >= 12) {
    double secondProb = probs.get(1).getProbability();
    double probDiff = topProb - secondProb;
    
    // 要求：差异 > 40% 且第一名概率 > 60%
    if (probDiff > 0.40 && topProb > 0.60) {
        return true;  // 结束诊断
    }
}
```

**示例**：
- 第一名概率：70%
- 第二名概率：25%
- 差异：45% > 40% ✓
- 第一名概率：70% > 60% ✓
- → 满足条件，结束诊断

### 条件4：强制结束条件

最多问30个问题后强制结束：

```java
if (questionCount >= 30) {
    return true;  // 强制结束
}
```

---

## 数据结构详解

### DiagnosisSession（诊断会话）

存储当前诊断会话的状态：

```java
public class DiagnosisSession {
    private List<Integer> selectedSymptoms;      // 用户选择"是"的症状ID列表
    private List<Integer> askedSymptoms;        // 所有已问过的症状ID列表
    private List<Integer> uncertainSymptoms;    // 用户回答"不确定"的症状ID列表
    private int questionCount;                   // 已回答的问题总数
    private Integer mainComplaintId;             // 主诉症状ID
    private List<Integer> recentAskedSymptoms;   // 最近问过的3个症状ID
    
    // 方法
    public void addRecentAskedSymptom(Integer symptomId);
    public boolean isRecentlyAsked(Integer symptomId);
    public void addUncertainSymptom(Integer symptomId);
    public boolean isUncertain(Integer symptomId);
}
```

### DiseaseResult（疾病结果）

存储疾病及其计算出的概率：

```java
public class DiseaseResult {
    private Disease disease;                     // 疾病对象
    private double probability;                  // 概率（0.0-1.0）
    private List<DiseaseSymptom> evidenceSymptoms;  // 证据症状列表
    private String recommendation;               // 诊疗建议
}
```

### DiseaseSymptom（疾病-症状关系）

存储疾病和症状的关联关系：

```java
public class DiseaseSymptom {
    private Integer diseaseId;      // 疾病ID
    private Integer symptomId;      // 症状ID
    private Float weight;           // 权重（0-100，默认100）
    private Boolean isRequired;     // 是否必需症状
    private Boolean isExclusive;   // 是否互斥症状
}
```

### SymptomWithWeight（症状及权重）

用于问题选择，包含症状及其在某个疾病中的权重：

```java
public class SymptomWithWeight {
    private Symptom symptom;        // 症状对象
    private Integer diseaseId;      // 关联的疾病ID
    private Double weight;          // 权重
    private Boolean isRequired;     // 是否必需
    private Boolean isExclusive;    // 是否互斥
}
```

---

## API接口规范

### 1. 获取主诉选项

**请求**：
```
GET /petblog/api/diagnosis/main-complaints
```

**响应**：
```json
{
  "questions": [
    {
      "symptomId": 1,
      "symptomName": "发热",
      "questionText": "您的宠物是否有发热相关的症状？"
    }
  ]
}
```

### 2. 获取下一个问题

**请求**：
```
POST /petblog/api/diagnosis/next
Content-Type: application/json

{
  "selectedSymptoms": [1, 2, 3],
  "askedSymptoms": [1, 2, 3, 4, 5],
  "uncertainSymptoms": [6],
  "questionCount": 5,
  "mainComplaintId": 1,
  "questionHistory": [...]
}
```

**响应（继续问诊）**：
```json
{
  "finished": false,
  "nextQuestion": {
    "id": 10,
    "name": "咳嗽",
    "category": "呼吸系统"
  },
  "nextSymptomId": 10,
  "name": "咳嗽",
  "description": ""
}
```

**响应（诊断完成）**：
```json
{
  "finished": true,
  "diseases": [
    {
      "diseaseId": 1,
      "disease": "感冒",
      "probability": 0.65,
      "description": "疾病描述...",
      "evidenceSymptoms": [
        {"symptomName": "咳嗽"},
        {"symptomName": "发热"}
      ],
      "recommendation": "建议..."
    }
  ]
}
```

### 3. 保存问诊记录

**请求**：
```
POST /petblog/api/diagnosis/save
Content-Type: application/json

{
  "userId": 1,
  "selectedSymptoms": [1, 2, 3],
  "resultDiseaseId": 5,
  "probability": 0.65
}
```

**响应**：
```json
{
  "success": true,
  "consultationId": 123
}
```

---

## 关键公式总结

### 1. 概率计算公式

```
对于疾病 D：

步骤1：计算分母（TotalScore）
  TotalScore(D) = Σ [weight(s) × multiplier(s)]
  
  其中：
    multiplier(s) = {
      2.0  if s is required
      1.0  otherwise
    }

步骤2：计算分子（CurrentScore）
  CurrentScore(D) = Σ [weight(s) × multiplier(s)]  (s in selectedSymptoms)

步骤3：计算基础概率
  probability(D) = CurrentScore(D) / TotalScore(D)

步骤4：应用惩罚
  if (强必需症状被否定):
    probability(D) *= 0.1
  else if (弱必需症状被否定):
    probability(D) *= 0.4
    
  if (疾病不包含主诉):
    probability(D) *= 0.5

步骤5：限制最大概率
  if (probability(D) > 0.95):
    probability(D) = 0.95
```

### 2. 问题选择得分公式

```
Score(symptom s) = Σ [weight(s,d) × P(d)] × categoryBonus(s)

其中：
  weight(s,d) = {
    baseWeight(s,d) × 1.5  if s is required in d
    baseWeight(s,d)         otherwise
  }
  
  P(d) = 疾病d的当前概率
  
  categoryBonus(s) = {
    1.5  if category(s) == category(mainComplaint)
    1.0  otherwise
  }
```

### 3. 结束条件公式

```
结束条件 = (问题数 >= 8) AND (
    (概率 >= 动态阈值) OR
    (问题数 >= 12 AND 概率差异 > 40% AND 第一名概率 > 60%) OR
    (问题数 >= 30)
)

动态阈值 = {
    90%  if 问题数 <= 8
    85%  if 问题数 <= 12
    75%  if 问题数 <= 16
    65%  if 问题数 <= 20
    55%  otherwise
}
```

---

## 算法优化与改进

### 改进1：主诉权重增强

**问题**：主诉是用户来看病的核心原因，如果主诉是"呕吐"，那么所有不包含"呕吐"症状的疾病，理论上概率应该极低。

**解决方案**：
- 在计算概率时，检查疾病是否包含主诉症状
- 如果疾病不包含主诉症状，概率乘以0.5

**代码实现**：
```java
// 检查疾病是否包含主诉症状
boolean containsMainComplaint = false;
if (mainComplaintId != null) {
    containsMainComplaint = symptoms.stream()
        .anyMatch(ds -> ds.getSymptomId().equals(mainComplaintId));
}

// 如果疾病不包含主诉症状，概率降低50%
if (mainComplaintId != null && !containsMainComplaint) {
    probability *= 0.5;
}
```

### 改进2：增加"不确定"选项

**问题**：很多症状用户是不知道的。如果用户被迫选"否"，会错误地触发"必需症状被否定"的惩罚。

**解决方案**：
- 前端增加"不确定"按钮
- 后端区分"否"和"不确定"
- "不确定"不触发必需症状惩罚

**代码实现**：
```java
// 只有明确回答"否"（在asked里但不在selected里，且不在uncertain里）才触发惩罚
else if (askedIds.contains(symptomId) && !uncertainIds.contains(symptomId)) {
    // 触发必需症状惩罚
}
// 如果症状在uncertainIds中，既不加分也不触发必需症状惩罚
```

### 改进3：优化必需症状否定惩罚

**问题**：0.1的惩罚非常重。有些"必需症状"可能在病程早期并不明显。

**解决方案**：
- 分级惩罚机制
- 强必需（权重>80）：概率×0.1
- 弱必需（权重≤80）：概率×0.4

**代码实现**：
```java
if (ds.getIsRequired() != null && ds.getIsRequired()) {
    double symptomWeight = (ds.getWeight() != null) ? ds.getWeight() : 100.0;
    if (symptomWeight > 80.0) {
```

### 改进4：实现特异性症状（isExclusive）逻辑

**问题**：某些疾病具有高度特征性的症状（如"犬细小病毒"的腥臭血便），这些症状一旦出现，确诊率应该接近100%。但现有算法只把它们当作普通加分项处理。

**解决方案**：
- 在数据库中将高度特征性的症状标记为 `is_exclusive=1`
- 当特异性症状被选中时，对应疾病的概率直接提升到95%（接近确诊）
- 使用500分的额外加分确保该疾病排到第一名

**代码实现**：
```java
// 在计算得分时
if (selectedIds.contains(symptomId)) {
    currentScore += effectiveWeight;
    
    // 特异性症状奖励
    if (ds.getIsExclusive() != null && ds.getIsExclusive()) {
        currentScore += 500.0;  // 巨大加分
        hasExclusiveSymptom = true;
    }
}

// 在计算概率后
if (hasExclusiveSymptom) {
    probability = 0.95;  // 直接设为95%
} else {
    // 其他惩罚逻辑...
}
```

**数据库标记示例**：
- 犬细小病毒肠炎：便血 → `is_exclusive=1`
- 犬耳螨感染：耳朵有分泌物、摇头频繁 → `is_exclusive=1`
- 犬膀胱炎：尿血 → `is_exclusive=1`
- 犬癫痫：癫痫发作 → `is_exclusive=1`

**效果**：
- 当用户选中"便血"时，"犬细小病毒肠炎"的概率直接提升到95%
- 当用户选中"耳道黑褐色分泌物"时，"耳螨感染"的概率直接提升到95%
- 提高了诊断的准确性和效率
        // 强必需症状被否定
        criticalSymptomMissing = true;
    } else {
        // 弱必需症状被否定
        weakRequiredSymptomMissing = true;
    }
}

// 应用惩罚
if (criticalSymptomMissing) {
    probability *= 0.1;  // 强必需：降低到10%
} else if (weakRequiredSymptomMissing) {
    probability *= 0.4;  // 弱必需：降低到40%
}
```

---

## 完整计算示例

### 示例场景

假设：
- 主诉：症状ID=1（"呕吐"）
- 用户已选择症状：[1, 3, 5]
- 用户已问过症状：[1, 2, 3, 4, 5, 6]
- 用户不确定症状：[4]
- 疾病A有症状：[1(权重80), 2(权重60,必需), 3(权重90), 4(权重70)]

### 计算过程

**步骤1：检查主诉**
- 疾病A包含症状1（主诉）→ `containsMainComplaint = true`

**步骤2：遍历症状**

- **症状1（权重80）**：
  - 在selectedIds中 → `currentScore += 80`
  - `totalPossibleScore += 80`

- **症状2（权重60，必需）**：
  - 在askedIds中但不在selectedIds中，且不在uncertainIds中 → 明确回答"否"
  - 是必需症状，权重60 ≤ 80 → `weakRequiredSymptomMissing = true`
  - `totalPossibleScore += 60 * 2 = 120`（必需症状权重加倍）

- **症状3（权重90）**：
  - 在selectedIds中 → `currentScore += 90`
  - `totalPossibleScore += 90`

- **症状4（权重70）**：
  - 在uncertainIds中 → 既不加分也不触发惩罚
  - `totalPossibleScore += 70`

**步骤3：计算基础概率**
- `totalPossibleScore = 80 + 120 + 90 + 70 = 360`
- `currentScore = 80 + 90 = 170`
- `probability = 170 / 360 = 0.472 = 47.2%`

**步骤4：应用惩罚**
- 弱必需症状被否定 → `probability *= 0.4`
- `probability = 47.2% × 0.4 = 18.9%`

**步骤5：主诉检查**
- 疾病包含主诉 → 不应用主诉惩罚

**步骤6：限制最大概率**
- `18.9% < 95%` → 不限制

**最终概率**：18.9%

---

## 算法复杂度分析

### 时间复杂度

- **概率计算**: O(D × S)，其中 D 是疾病数量，S 是平均每个疾病的症状数
- **问题选择**: O(T × C)，其中 T 是Top疾病数量（通常3-5），C 是候选症状数量（通常10-20）
- **总体复杂度**: 每次调用 `nextStep()` 为 O(D × S + T × C)，通常 < 1000 次操作

### 空间复杂度

- **疾病-症状映射**: O(D × S)
- **候选症状列表**: O(C)
- **总体空间复杂度**: O(D × S + C)

---

## 算法优势

1. **直观易懂**：匹配度百分比比传统概率更容易理解
2. **快速计算**：简单的加减法运算，无需复杂的概率计算
3. **准确有效**：通过权重和必需症状标记，准确反映症状重要性
4. **智能选择**：聚焦Top疾病，提高问诊效率
5. **防止过早结束**：最少问题数要求，确保收集足够信息
6. **主诉权重增强**：不包含主诉的疾病概率降低，更符合实际
7. **分级惩罚**：必需症状被否定时，根据权重分级惩罚，避免过度惩罚
8. **不确定选项**：支持用户回答"不确定"，不误触发惩罚

---

**文档版本**: v3.0  
**最后更新**: 2024年  
**维护者**: 系统开发团队

